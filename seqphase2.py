# Generated by Haxe 3.4.4
# coding: utf-8

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import builtins as python_lib_Builtins
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import re as python_lib_Re
import subprocess as python_lib_Subprocess
import sys as python_lib_Sys
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import timeit as python_lib_Timeit
try:
    import tty as python_lib_Tty
except:
    pass
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")



class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["split"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g1 = 0
        _g = len(opt)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x3 = HxString.substr(s,lastEnd,None)
            ret.append(x3)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]



class EnumValue:
    _hx_class_name = "EnumValue"


class Individual:
    _hx_class_name = "Individual"
    __slots__ = ("name", "seq1", "seq2", "index", "p")
    _hx_fields = ["name", "seq1", "seq2", "index", "p"]
    _hx_methods = ["getName", "getSequence1", "getSequence2", "getIndex", "getProbability", "isHomozygous", "isHeterozygous", "getFasta"]

    def __init__(self,name,seq1,seq2,index,p):
        self.name = name
        self.seq1 = seq1
        self.seq2 = seq2
        self.index = index
        self.p = p

    def getName(self):
        return self.name

    def getSequence1(self):
        return self.seq1

    def getSequence2(self):
        return self.seq2

    def getIndex(self):
        return self.index

    def getProbability(self):
        return self.p

    def isHomozygous(self):
        return (self.seq1 == self.seq2)

    def isHeterozygous(self):
        return (self.seq1 != self.seq2)

    def getFasta(self,reduce,outFile):
        result = List()
        if (self.p == 1.0):
            if (self.isHomozygous() and reduce):
                result.add((">" + HxOverrides.stringOrNull(self.name)))
                result.add(self.seq1)
            else:
                result.add(((">" + HxOverrides.stringOrNull(self.name)) + "a"))
                result.add(self.seq1)
                result.add(((">" + HxOverrides.stringOrNull(self.name)) + "b"))
                result.add(self.seq2)
        elif (self.isHomozygous() and reduce):
            result.add(((((((">" + HxOverrides.stringOrNull(self.name)) + "-") + Std.string(self.index)) + "(") + Std.string(self.p)) + ")"))
            result.add(self.seq1)
        else:
            result.add(((((((">" + HxOverrides.stringOrNull(self.name)) + "-") + Std.string(self.index)) + "a(") + Std.string(self.p)) + ")"))
            result.add(self.seq1)
            result.add(((((((">" + HxOverrides.stringOrNull(self.name)) + "-") + Std.string(self.index)) + "b(") + Std.string(self.p)) + ")"))
            result.add(self.seq2)
        return result.join("\n")



class Individuals:
    _hx_class_name = "Individuals"
    __slots__ = ("inds", "outFile")
    _hx_fields = ["inds", "outFile"]
    _hx_methods = ["addIndividual", "setOutFile", "getFasta"]

    def __init__(self):
        self.outFile = None
        self.inds = list()

    def addIndividual(self,ind):
        _this = self.inds
        _this.append(ind)

    def setOutFile(self,b):
        self.outFile = b

    def getFasta(self,reduce,sort):
        result = List()
        def _hx_local_0(i1,i2):
            if (i1.getName() < i2.getName()):
                return -1
            if (i1.getName() > i2.getName()):
                return 1
            return (i1.getIndex() - i2.getIndex())
        self.inds.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        _g = 0
        _g1 = self.inds
        while (_g < len(_g1)):
            ind = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            result.add(ind.getFasta(reduce,self.outFile))
        return result.join("\n")



class List:
    _hx_class_name = "List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "pop", "toString", "join"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = _List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def pop(self):
        if (self.h is None):
            return None
        x = self.h.item
        self.h = self.h.next
        if (self.h is None):
            self.q = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 - 1)
        _hx_local_1
        return x

    def toString(self):
        s_b = python_lib_io_StringIO()
        first = True
        l = self.h
        s_b.write("{")
        while (l is not None):
            if first:
                first = False
            else:
                s_b.write(", ")
            s_b.write(Std.string(Std.string(l.item)))
            l = l.next
        s_b.write("}")
        return s_b.getvalue()

    def join(self,sep):
        s_b = python_lib_io_StringIO()
        first = True
        l = self.h
        while (l is not None):
            if first:
                first = False
            else:
                s_b.write(Std.string(sep))
            s_b.write(Std.string(l.item))
            l = l.next
        return s_b.getvalue()



class _List_ListNode:
    _hx_class_name = "_List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next



class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class SeqPhase2:
    _hx_class_name = "SeqPhase2"
    __slots__ = ()
    _hx_statics = ["code", "supercode", "revSupercode", "removePossibleLineEndingR", "genConstString", "nSplit", "nrsToSeq", "parsePairFile", "stripBraces", "getSumCode", "processLines", "parseOutFile", "parse", "main"]

    @staticmethod
    def removePossibleLineEndingR(line):
        if (len(line) >= 1):
            if ((("" if ((0 >= len(line))) else line[0])) == "\r"):
                line = HxString.substr(line,1,None)
            index = (len(line) - 1)
            if ((("" if (((index < 0) or ((index >= len(line))))) else line[index])) == "\r"):
                line = HxString.substr(line,0,(len(line) - 1))
        return StringTools.trim(line)

    @staticmethod
    def genConstString(length):
        result = List()
        _g1 = 0
        _g = length
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            result.add(".")
        return result.join("")

    @staticmethod
    def nSplit(s):
        result = List()
        _g1 = 0
        _g = len(s)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            char = ("" if (((i < 0) or ((i >= len(s))))) else s[i])
            if (char == " "):
                continue
            result.add(char)
        return result

    @staticmethod
    def nrsToSeq(nrs,const):
        nrs1 = SeqPhase2.nSplit(nrs)
        if ((const is None) or ((const == ""))):
            const = SeqPhase2.genConstString(nrs1.length)
        codeS = List()
        _g_head = nrs1.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            part = val
            i = Std.parseInt(part)
            r = SeqPhase2.code.h.get(i,None)
            if (r is None):
                raise _HxException((((("Error: The .out/.out_pairs file contains an allele not present in the input dataset (" + Std.string(i)) + ", ") + Std.string(nrs1)) + ")"))
            codeS.add(r)
        doesNotMatch = False
        result = List()
        _g1 = 0
        _g = len(const)
        while (_g1 < _g):
            i1 = _g1
            _g1 = (_g1 + 1)
            _hx_chr = ("" if (((i1 < 0) or ((i1 >= len(const))))) else const[i1])
            if (_hx_chr == "."):
                nextCodeS = codeS.pop()
                if (nextCodeS is None):
                    doesNotMatch = True
                    break
                result.add(nextCodeS)
            else:
                result.add(_hx_chr)
        if (doesNotMatch or ((codeS.length != 0))):
            raise _HxException((((("Error: The data in the const and in the input file do not match; please check input data. (" + Std.string(doesNotMatch)) + ", ") + Std.string(codeS.length)) + ")"))
        return result.join("")

    @staticmethod
    def parsePairFile(fileContent,const = ""):
        if (const is None):
            const = ""
        result = Individuals()
        result.setOutFile(False)
        lineNo = 0
        currentIndividualName = ""
        index = 0
        _g = 0
        _g1 = fileContent.split("\n")
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            line = SeqPhase2.removePossibleLineEndingR(line)
            lineNo = (lineNo + 1)
            if (line != ""):
                if (HxString.substr(line,0,5) == "IND: "):
                    currentIndividualName = HxString.substr(line,5,None)
                    index = 1
                else:
                    parts = line.split(" , ")
                    if (len(parts) != 3):
                        raise _HxException((("Please check line " + Std.string(lineNo)) + " in the input file!"))
                    seq1 = SeqPhase2.nrsToSeq((parts[0] if 0 < len(parts) else None),const)
                    seq2 = SeqPhase2.nrsToSeq((parts[1] if 1 < len(parts) else None),const)
                    probability = Std.parseFloat((parts[2] if 2 < len(parts) else None))
                    ind = index
                    index = (index + 1)
                    ind1 = Individual(currentIndividualName,seq1,seq2,ind,probability)
                    result.addIndividual(ind1)
        return result

    @staticmethod
    def stripBraces(c):
        if ((("" if ((0 >= len(c))) else c[0])) == "("):
            c = HxString.substr(c,1,None)
        index = (len(c) - 1)
        if ((("" if (((index < 0) or ((index >= len(c))))) else c[index])) == ")"):
            c = HxString.substr(c,0,(len(c) - 1))
        return c

    @staticmethod
    def getSumCode(c1,c2):
        c1 = SeqPhase2.stripBraces(c1)
        c2 = SeqPhase2.stripBraces(c2)
        code1 = Std.parseInt(c1)
        code2 = Std.parseInt(c2)
        code1S = SeqPhase2.code.h.get(code1,None)
        code2S = SeqPhase2.code.h.get(code2,None)
        codeSum = (SeqPhase2.supercode.h.get(code1S,None) + SeqPhase2.supercode.h.get(code2S,None))
        return SeqPhase2.revSupercode.h.get(codeSum,None)

    @staticmethod
    def processLines(indName,seqLine1,seqLine2,const,lineNo):
        result = List()
        r = EReg(" +","g")
        pLine1 = r.split(seqLine1)
        pLine2 = r.split(seqLine2)
        if (len(pLine1) != len(pLine2)):
            raise _HxException((((("Error: Sequences have different lengths. Please check sequences of individual " + ("null" if indName is None else indName)) + " (line ") + Std.string(((lineNo - 2)))) + "ff.) in input file."))
        if ((const is None) or ((const == ""))):
            const = SeqPhase2.genConstString(len(pLine1))
        r1 = List()
        r2 = List()
        _g1 = 0
        _g = len(pLine1)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c1 = (pLine1[i] if i >= 0 and i < len(pLine1) else None)
            c2 = (pLine2[i] if i >= 0 and i < len(pLine2) else None)
            processed1 = False
            processed2 = False
            if ((("" if ((0 >= len(c1))) else c1[0])) == "["):
                r1.add("N")
                processed1 = True
            if ((("" if ((0 >= len(c2))) else c2[0])) == "["):
                r2.add("N")
                processed2 = True
            if ((("" if ((0 >= len(c1))) else c1[0])) == "("):
                toAdd = SeqPhase2.getSumCode(c1,c2)
                if ((toAdd is None) or ((toAdd == ""))):
                    raise _HxException((((((((((("Unexpected input: Parsing error for " + ("null" if indName is None else indName)) + " ") + ("null" if toAdd is None else toAdd)) + " ") + Std.string(i)) + " ") + ("null" if c1 is None else c1)) + " ") + ("null" if c2 is None else c2)) + " (1)"))
                r1.add(toAdd)
                processed1 = True
            if ((("" if ((0 >= len(c2))) else c2[0])) == "("):
                toAdd1 = SeqPhase2.getSumCode(c2,c1)
                if ((toAdd1 is None) or ((toAdd1 == ""))):
                    raise _HxException((((((((((("Unexpected input: Parsing error for " + ("null" if indName is None else indName)) + " ") + ("null" if toAdd1 is None else toAdd1)) + " ") + Std.string(i)) + " ") + ("null" if c1 is None else c1)) + " ") + ("null" if c2 is None else c2)) + " (2)"))
                r2.add(toAdd1)
                processed2 = True
            if (not processed1):
                _this = SeqPhase2.code
                key = Std.parseInt(c1)
                toAdd2 = _this.h.get(key,None)
                if ((toAdd2 is None) or ((toAdd2 == ""))):
                    raise _HxException((((((((((("Unexpected input: Parsing error for " + ("null" if indName is None else indName)) + " ") + ("null" if toAdd2 is None else toAdd2)) + " ") + Std.string(i)) + " ") + ("null" if c1 is None else c1)) + " ") + ("null" if c2 is None else c2)) + " (3)"))
                r1.add(toAdd2)
            if (not processed2):
                _this1 = SeqPhase2.code
                key1 = Std.parseInt(c2)
                toAdd3 = _this1.h.get(key1,None)
                if ((toAdd3 is None) or ((toAdd3 == ""))):
                    raise _HxException((((((((((("Unexpected input: Parsing error for " + ("null" if indName is None else indName)) + " ") + ("null" if toAdd3 is None else toAdd3)) + " ") + Std.string(i)) + " ") + ("null" if c1 is None else c1)) + " ") + ("null" if c2 is None else c2)) + " (4)"))
                r2.add(toAdd3)
        seq1 = List()
        seq2 = List()
        doesNotMatch = False
        _g11 = 0
        _g2 = len(const)
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            _hx_chr = ("" if (((i1 < 0) or ((i1 >= len(const))))) else const[i1])
            if (_hx_chr == "."):
                r1S = r1.pop()
                r2S = r2.pop()
                if ((r1S is None) or ((r2S is None))):
                    doesNotMatch = True
                    break
                seq1.add(r1S)
                seq2.add(r2S)
            else:
                seq1.add(_hx_chr)
                seq2.add(_hx_chr)
        if ((doesNotMatch or ((r1.length != 0))) or ((r2.length != 0))):
            raise _HxException((((((("Error: The data in the const and in the input file do not match; please check input data. (" + Std.string(doesNotMatch)) + ", ") + Std.string(r1.length)) + ", ") + Std.string(r2.length)) + ")"))
        ind = Individual(indName,seq1.join(""),seq2.join(""),-1,1.0)
        result.add(ind)
        return result

    @staticmethod
    def parseOutFile(fileContent,const = ""):
        if (const is None):
            const = ""
        result = Individuals()
        result.setOutFile(True)
        lineNo = 0
        currentIndividualName = None
        currentSeq1 = None
        currentSeq2 = None
        index = 0
        seenBeginBestPairs1 = False
        _g = 0
        _g1 = fileContent.split("\n")
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            line = SeqPhase2.removePossibleLineEndingR(line)
            lineNo = (lineNo + 1)
            if ((line == "BEGIN BESTPAIRS1") or ((line == "BEGIN GENOTYPES"))):
                seenBeginBestPairs1 = True
            elif ((line == "END BESTPAIRS1") or ((line == "END GENOTYPES"))):
                break
            elif seenBeginBestPairs1:
                isThatAnEmptyLine = StringTools.trim(line)
                if (isThatAnEmptyLine == ""):
                    continue
                if (currentIndividualName is None):
                    currentIndividualName = HxOverrides.arrayGet(line.split(" "), 1)
                    if (currentIndividualName is None):
                        currentIndividualName = line
                elif (currentSeq1 is None):
                    currentSeq1 = line
                else:
                    currentSeq2 = line
                    _g2_head = SeqPhase2.processLines(currentIndividualName,currentSeq1,currentSeq2,const,lineNo).h
                    while (_g2_head is not None):
                        val = _g2_head.item
                        _g2_head = _g2_head.next
                        ind = val
                        result.addIndividual(ind)
                    currentIndividualName = None
                    currentSeq1 = None
        return result

    @staticmethod
    def parse(fileContent,const = ""):
        if (const is None):
            const = ""
        if (HxString.substr(fileContent,0,10) == "**********"):
            return SeqPhase2.parseOutFile(fileContent,const)
        elif (HxString.substr(fileContent,0,5) == "IND: "):
            return SeqPhase2.parsePairFile(fileContent,const)
        raise _HxException("Input file not recognized (this is neither a .out nor a .out_pairs file generated by PHASE)")

    @staticmethod
    def main():
        Sys.stderr().writeString("SeqPHASE commmand-line version, Step 2: converting PHASE output files into FASTA alignments\n\n")
        Sys.stderr().writeString("Reference:\nFlot, J.-F. (2010) SeqPHASE: a web tool for interconverting PHASE input/output files and FASTA sequence alignments\nMolecular Ecology Ressources 10 (1): 162-166\n\n")
        Sys.stderr().writeString("Usage: perl seqphase2.pl -c <constant position file> -i <input=PHASE output file> -o <output=FASTA file name> [-r for reduced output] [-s for sorted output] \nThe constant position file (optional) was generated during Step 1 (without such file, the output FASTA will only contain the variable positions).\nInput=PHASE output file (compulsory) may be either .out or .out_pairs.\nOutput=FASTA file name (when not specified, default is 'phased.fasta'): if generated from an .out file, it will contain a list of phased haplotypes with 1-letter indetermination code letters (R, W, M, Y, S or K) at positions where phase certainty is inferior to a certain threshold (90% if PHASE default running options were used); if generated from an .out_pairs file, it will contain all possible haplotype pairs for each individual with their respective probabilities shown between parentheses.\nThe FASTA output may be reduced to show only posterior probabilities inferior to 1 and only one sequence per homozygote (-r switch) and/or be sorted alphabetically (-s switch).\n\n")
        myArgs = Sys.args()
        fileContent = None
        outfile = "phased.fasta"
        constFileContent = ""
        reduce = False
        sort = False
        i = 0
        while (i < len(myArgs)):
            current = (myArgs[i] if i >= 0 and i < len(myArgs) else None)
            if (current == "-r"):
                reduce = True
            elif (current == "-s"):
                sort = True
            elif (current == "-i"):
                i = (i + 1)
                myArgs1 = i
                fileContent = sys_io_File.getContent((myArgs[myArgs1] if myArgs1 >= 0 and myArgs1 < len(myArgs) else None))
            elif (current == "-o"):
                i = (i + 1)
                outfile1 = i
                outfile = (myArgs[outfile1] if outfile1 >= 0 and outfile1 < len(myArgs) else None)
            elif (current == "-c"):
                i = (i + 1)
                myArgs2 = i
                constFileContent = sys_io_File.getContent((myArgs[myArgs2] if myArgs2 >= 0 and myArgs2 < len(myArgs) else None))
            else:
                Sys.stderr().writeString((("Error: Unknown commandline option " + ("null" if current is None else current)) + "\n"))
                Sys.exit(1)
            i = (i + 1)
        if (fileContent is None):
            Sys.stderr().writeString("No input file specified.\n")
            Sys.exit(1)
        result = SeqPhase2.parse(fileContent,constFileContent)
        resultFileContent = result.getFasta(reduce,sort)
        fout = sys_io_File.write(outfile,False)
        fout.writeString(resultFileContent)
        fout.close()
        Sys.stderr().writeString("A FASTA alignments of phased haplotypes pairs")
        if sort:
            Sys.stderr().writeString(" (sorted alphabetically)")
        Sys.stderr().writeString(((" has been saved under " + ("null" if outfile is None else outfile)) + ".\n"))
        Sys.exit(0)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                prefix = HxString.substr(x,0,2).lower()
                if (prefix == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g1 = 0
        _g = len(x)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g21 = _g2
                if (((((((((((_g21 == 57) or ((_g21 == 56))) or ((_g21 == 55))) or ((_g21 == 54))) or ((_g21 == 53))) or ((_g21 == 52))) or ((_g21 == 51))) or ((_g21 == 50))) or ((_g21 == 49))) or ((_g21 == 48))) or ((_g21 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith", "isSpace", "ltrim", "rtrim", "trim"]

    @staticmethod
    def startsWith(s,start):
        if (len(s) >= len(start)):
            return (HxString.substr(s,0,len(start)) == start)
        else:
            return False

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["fullPath"]

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]

    def __init__(self):
        self.h = dict()



class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has



class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "time", "exit", "print", "println", "args", "getEnv", "putEnv", "environment", "sleep", "setTimeLocale", "getCwd", "setCwd", "systemName", "command", "cpuTime", "executablePath", "_programPath", "programPath", "getChar", "stdin", "stdout", "stderr"]

    @staticmethod
    def time():
        return python_lib_Time.time()

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def print(v):
        python_Lib.print(v)

    @staticmethod
    def println(v):
        python_Lib.println(v)

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def putEnv(s,v):
        python_lib_Os.putenv(s,v)
        Sys.environ.h[s] = v

    @staticmethod
    def environment():
        return Sys.environ

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def setTimeLocale(loc):
        return False

    @staticmethod
    def getCwd():
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if StringTools.startsWith(x,"linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def cpuTime():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def executablePath():
        return python_internal_ArrayImpl._get(python_lib_Sys.argv, 0)

    @staticmethod
    def programPath():
        return Sys._programPath

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getch().decode("utf-8"),0)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        else:
            x1 = _g
            raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        if echo:
            python_Lib.print("".join(map(chr,[ch])))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)

    @staticmethod
    def stderr():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stderr)


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set"]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value



class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_statics = ["ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    @staticmethod
    def ofString(s):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)



class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b



class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeString(self,s):
        b = haxe_io_Bytes.ofString(s)
        self.writeFullBytes(b,0,b.length)



class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if isinstance(o,int):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        field1 = field
        _hx_local_0 = len(field1)
        if (_hx_local_0 == 10):
            if (field1 == "charCodeAt"):
                if isinstance(o,str):
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == "lastIndexOf"):
                if isinstance(o,str):
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == "toLowerCase"):
                if isinstance(o,str):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == "toUpperCase"):
                if isinstance(o,str):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == "substring"):
                if isinstance(o,str):
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == "copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field1 == "join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field1 == "push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == "sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == "shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == "slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field1 == "split"):
                if isinstance(o,str):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == "indexOf"):
                if isinstance(o,str):
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == "reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == "unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == "map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == "pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == "iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == "toString"):
                if isinstance(o,str):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == "charAt"):
                if isinstance(o,str):
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field1 == "concat"):
                if isinstance(o,list):
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field1 == "filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == "insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field1 == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == "remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == "splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field1 == "substr"):
                if isinstance(o,str):
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["print", "println", "anonToDict", "anonAsDict", "dictAsAnon"]

    @staticmethod
    def print(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.buffer.write((("" + ("null" if _hx_str is None else _hx_str)) + "\n").encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        return _hx_AnonObject(d)


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val



class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "arrayGet", "mapKwArgs"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def mapKwArgs(a,v):
        a1 = python_Lib.dictAsAnon(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if hasattr(a1,k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            return s[startIndex:(startIndex + _hx_len)]


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")



class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian"]


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def close(self):
        self.stream.close()



class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))



class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "close", "writeFullBytes", "writeString"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))



class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent", "write"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def write(path,binary = True):
        if (binary is None):
            binary = True
        mode = ("wb" if binary else "w")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)



class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "close", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s):
        self.impl.writeString(s)


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

def _hx_init_SeqPhase2_code():
    def _hx_local_0():
        _g = haxe_ds_IntMap()
        _g.set(1,"A")
        _g.set(2,"C")
        _g.set(3,"G")
        _g.set(4,"T")
        _g.set(-1,"N")
        _g.set(0,"-")
        return _g
    return _hx_local_0()
SeqPhase2.code = _hx_init_SeqPhase2_code()
def _hx_init_SeqPhase2_supercode():
    def _hx_local_0():
        _g = haxe_ds_StringMap()
        _g.h["A"] = 1
        _g.h["T"] = 2
        _g.h["G"] = 4
        _g.h["C"] = 8
        _g.h["R"] = 5
        _g.h["Y"] = 10
        _g.h["M"] = 9
        _g.h["K"] = 6
        _g.h["W"] = 3
        _g.h["S"] = 12
        _g.h["V"] = 13
        _g.h["B"] = 14
        _g.h["H"] = 11
        _g.h["D"] = 7
        _g.h["N"] = 15
        return _g
    return _hx_local_0()
SeqPhase2.supercode = _hx_init_SeqPhase2_supercode()
def _hx_init_SeqPhase2_revSupercode():
    def _hx_local_0():
        _g = haxe_ds_IntMap()
        _g.set(1,"A")
        _g.set(2,"T")
        _g.set(4,"G")
        _g.set(8,"C")
        _g.set(5,"R")
        _g.set(10,"Y")
        _g.set(9,"M")
        _g.set(3,"W")
        _g.set(12,"S")
        _g.set(6,"K")
        _g.set(13,"V")
        _g.set(14,"B")
        _g.set(11,"H")
        _g.set(7,"D")
        _g.set(15,"N")
        return _g
    return _hx_local_0()
SeqPhase2.revSupercode = _hx_init_SeqPhase2_revSupercode()
def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")

SeqPhase2.main()